### GraphQL学习笔记

[TOC]

## 1. 简介

GraphQL是一个新的API标准，相对于REST它更高效和灵活。它最初是Facebook的开源项目，现在由社区进行驱动。

GraphQL的核心是启用声明式数据获取，客户端可以精确指定其需要从API中获取哪些数据。GraphQL服务器不使用多个返回固定数据结构的endpoints，而仅公开一个endpoint并准确响应客户端要求的数据。（*这句话的理解方式后面再补充*）

### 1.1 GraphQL是一种API查询语言

对于大多数应用来说，它们需要从服务端获取存储在数据库中的数据。API的责任是对数据提供一个接口来满足应用程序的需要。

GraphQL通常被误认为是一直数据库技术，这是一种错误的认识，它是一种API查询语言，而不是数据库。从这种以用上来说，它和数据库无关，它可以在使用API任何情况下使用。

### 1.2 它是REST的一种更有效的替代

REST在当前环境下需要面对的问题：

1. 移动应用使用量的增加导致更加有效加载数据的需求
2. 各种不同的前端框架和平台对API提出了挑战。同一个API很难适合各种不同前端的需求。
3. 快速开发和对快速开发功能的期望。快速的迭代和频繁的产品更新是必不可少的。它经常需要修改服务器对外暴露的数据，并要求客户端做修改。这阻碍了快速开发实践和产品的迭代。

### 1.3 GraphQL比REST更优秀

#### 数据的获取方式REST和GraphQL比较

使用REST API，你通常需要多次请求来收集数据，如下面的例子：

![image-20191217152753950](C:\Users\haiyanaz\AppData\Roaming\Typora\typora-user-images\image-20191217152753950.png)

使用GraphQL，你只需要向服务器发一次包含具体数据要求的查询即可。然后，服务器将会返回满足这些要求的JSON对象。

![image-20191217153319136](C:\Users\haiyanaz\AppData\Roaming\Typora\typora-user-images\image-20191217153319136.png)

#### 不再需要过度获取和获取不足

REST最常见的问题之一是过度获取或者获取不足（例如上面举的例子）。发生这种情况的原因是，客户端下载数据的唯一方法是通过命中endpoints（即访问不同的API endpoints）返回固定的数据结构。以能够为客户提供确切数据需求的方式设计API是非常困难的。

##### 过度获取：下载多余的数据

指的是客户端下载的数据比实际需要使用的要多。

##### 获取不足和n+1问题

获取不足意味着特定的endpoint无法提供足够的必须信息。客户端不得不多次请求以获取它所需要的全部内容。

##### 前端的快速产品迭代

REST API的常见模式是根据应用程序内部的视图来构造endpoint。这很方便，因为它运行客户端通过简单地方式访问相应的endpoint来获取特定试视图的所有必须信息。

这种方法的主要缺点是不允许前端进行快速迭代。每次对UI进行更改后，都存在比以前需要更多（或更少）数据的风险。相应的，后端还需要进行调整以解决新数据的需求。这降低了生产力，并且显著降低将用户反馈整合到产品中的能力。

使用GraphQL，可以解决此问题。由于GraphQL具有灵活的特性，客户端可以进行修改而服务器上不需要进行额外的修改。 由于客户端可以指定确切的数据要求，因此当前端的设计和数据需求发生变化是，无需后端工程师进行调整。

##### 后端的深入分析

GraphGL可以让你对后端请求的数据有更深入的了解。由于每个客户端都准确的指明了感兴趣的信息，因此可以更深入的了解这些数据是如何被使用的，例如，这可以帮助改进API，并弃用任何客户端都不再请求的那些字段。

使用GraphGL，你还可以对服务器处理的请求进行更低层级的性能监视。GraphGL使用Resolver的概念来收集客户端请求的数据。对于这些Resolver的性能进行测量，可以提供有关系统性能瓶颈的关键见解。
（*这段话的通俗理解是，客户端请求的数据都是精确的，不像REST存在过度或不足获取，那么这些请求可以准确的反应客户端需求，服务端则可以通过对这些数据进行低层级监控来发现系统中的不足并进行改进*）

##### 模式（schema）和类型系统的好处

GraphGL使用强类型系统定义API的能力。在一个API中暴露的所有类型都写在一个GraphQL模式定义语言（SDL）的schema中，这个schema充当客户端和服务端之间的协定，以定义客户端如何访问服务端数据。

一旦定义了schema。前端和后端团队就可以进行工作而无需进一步的沟通，因为他们已知道了通过网球发送的数据的确切结构。

前端团队可以通过模拟所需要的数据结构轻松地测试其应用程序。等服务端准备就绪后，可以切换到真实环境进行测试。

## 2. 核心概念

### 用SDL写Schema

GraphQL有自己的类型系统，用于定义API的Schema。写schema的语法称为Schema Definition Language(SDL)。

这儿有一个示例，我们如何定义一个Person的简单类型：

```typescript
type Person {
  name: String!
  age: Int!
}
```

这个类型有2个字段`name`和`age`，它们的类型分别是`String`和`Int`，其中后面`!`代表这个字段是必须的。

也可以表达不同类型之间的关系。举个博客应用程序的例子，一个`Person`可以和一个帖子`Post`关联：

```typescript
type Post {
  title: String!
  author: Person!
}
```

相反地，关系的另一端需要放在`Person`类型上：

```typescript
type Person {
  name: String!
  age: Int!
  posts: [Post!]!
}
```

我们刚刚在`Person`和`Post`之间创建了一个一对多关系，因为在posts字段是一个`Person`数组。

### 用查询获取数据

